let marketCondition = "BAD";
let safeToEnter = false;
let recentlySpiked = false;
let nextMove = "sideways";
let pullbackStatus = "RISKY ZONE";

async function getBTCIndicators() {
  const res = await fetch("https://fapi.binance.com/fapi/v1/klines?symbol=BTCUSDT&interval=5m&limit=250");
  const data = await res.json();

  const closes = data.map(c => parseFloat(c[4]));
  const highs = data.map(c => parseFloat(c[2]));
  const lows = data.map(c => parseFloat(c[3]));
  const volumes = data.map(c => parseFloat(c[5]));

  const ema50 = getEMA(closes, 50);
  const ema200 = getEMA(closes, 200);
  const rsi = calculateRSI(closes, 14);
  const atr = calculateATR(highs, lows, closes, 14);
  const { macdLine, signalLine } = calculateMACD(closes);

  const priceNow = closes[closes.length - 1];
  const priceBefore = closes[closes.length - 18];
  const currentVolume = volumes[volumes.length - 1];
  const avgVolume = volumes.slice(-30).reduce((a, b) => a + b, 0) / 30;

  const rsiNow = rsi[rsi.length - 1];
  const atrNow = atr[atr.length - 1];
  const ema50Now = ema50[ema50.length - 1];
  const ema50Prev = ema50[ema50.length - 4];
  const ema200Now = ema200[ema200.length - 1];

  const slope = ema50Now - ema50Prev;
  const dynamicSlopeThreshold = 0.2 * (atrNow / priceNow);

  // Spike detection
  const priceSpike = Math.abs(priceNow - priceBefore) / priceBefore > 0.015;
  const volumeStd = Math.sqrt(volumes.slice(-30).reduce((a, v) => a + Math.pow(v - avgVolume, 2), 0) / 30);
  const volumeZ = (currentVolume - avgVolume) / volumeStd;
  const volumeSpike = volumeZ > 2;
  const overextended = Math.abs(priceNow - ema50Now) > 2 * atrNow;
  const overboughtOrOversold = rsiNow > 75 || rsiNow < 25;

  // UPDATE GLOBAL
  recentlySpiked = (priceSpike && volumeSpike) || overextended || overboughtOrOversold;

  const macdNow = macdLine[macdLine.length - 1];
  const signalNow = signalLine[signalLine.length - 1];
  const macdUp = macdNow > signalNow;

  const bullishCrossover = ema50Now > ema200Now && ema50Prev <= ema200Now;
  const bearishCrossover = ema50Now < ema200Now && ema50Prev >= ema200Now;

  // UPDATE GLOBAL
  nextMove = bullishCrossover || (slope > dynamicSlopeThreshold && rsiNow > 55) ? "bullish"
           : bearishCrossover || (slope < -dynamicSlopeThreshold && rsiNow < 45) ? "bearish"
           : "sideways";

  safeToEnter = slope > dynamicSlopeThreshold && !recentlySpiked && macdUp;

  // UPDATE GLOBAL
  marketCondition = safeToEnter ? "GOOD" : "BAD";
  pullbackStatus = recentlySpiked ? "RISKY ZONE" : "SAFE ZONE";
}

  return {
    forecast,
    safeToTrade,
    recentlySpiked
  };
}

function getEMA(prices, period) {
  const k = 2 / (period + 1);
  const ema = [prices.slice(0, period).reduce((a, b) => a + b, 0) / period];
  for (let i = period; i < prices.length; i++) {
    ema.push(prices[i] * k + ema[ema.length - 1] * (1 - k));
  }
  return ema;
}

function calculateRSI(closes, period = 14) {
  let gains = 0, losses = 0;
  const rsi = [];

  for (let i = 1; i <= period; i++) {
    const change = closes[i] - closes[i - 1];
    if (change >= 0) gains += change;
    else losses -= change;
  }

  let avgGain = gains / period;
  let avgLoss = losses / period;
  rsi.push(100 - 100 / (1 + avgGain / avgLoss));

  for (let i = period + 1; i < closes.length; i++) {
    const change = closes[i] - closes[i - 1];
    const gain = Math.max(change, 0);
    const loss = Math.max(-change, 0);
    avgGain = (avgGain * (period - 1) + gain) / period;
    avgLoss = (avgLoss * (period - 1) + loss) / period;
    rsi.push(100 - 100 / (1 + avgGain / avgLoss));
  }

  return rsi;
}

function calculateATR(highs, lows, closes, period = 14) {
  const tr = [];
  for (let i = 1; i < highs.length; i++) {
    const high = highs[i];
    const low = lows[i];
    const prevClose = closes[i - 1];
    tr.push(Math.max(high - low, Math.abs(high - prevClose), Math.abs(low - prevClose)));
  }

  const atr = [tr.slice(0, period).reduce((a, b) => a + b, 0) / period];
  for (let i = period; i < tr.length; i++) {
    atr.push((atr[atr.length - 1] * (period - 1) + tr[i]) / period);
  }
  return atr;
}

    function calculateMACD(prices, shortPeriod = 12, longPeriod = 26, signalPeriod = 9) {
  const emaShort = getEMA(prices, shortPeriod);
  const emaLong = getEMA(prices, longPeriod);
  const macdLine = emaShort.slice(longPeriod - shortPeriod).map((v, i) => v - emaLong[i]);
  const signalLine = getEMA(macdLine, signalPeriod);
  return { macdLine, signalLine };
}

async function updateMarketCondition() {
  try {
    await getBTCIndicators();

    const marketEl = document.querySelector("#marketStatus .value");
    const pullbackEl = document.querySelector("#pullbackStatus .value");

    if (marketEl) {
      marketEl.innerHTML = `${marketCondition} / ${nextMove.toUpperCase()}`;
      marketEl.style.color = marketCondition === "GOOD" ? "#22c55e" : "#EF4444";
    }

    if (pullbackEl) {
      pullbackEl.innerHTML = pullbackStatus;
      pullbackEl.style.color = pullbackStatus === "SAFE ZONE" ? "#22c55e" : "#f97316";
    }

    toggleScanButton?.(); // Optional callback if defined
  } catch (err) {
    console.error("Market update error:", err);
  }
}

// Start real-time updates
updateMarketCondition();
setInterval(updateMarketCondition, 20000);
