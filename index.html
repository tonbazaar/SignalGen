<!DOCTYPE html>
<html>
<head>
  <title>Crypto Futures Signal Generator | Auto Trade with Binance API</title>
  <link rel="icon" type="image/png" href="/favicon_512x512.png">
  <meta name="description" content="Generate high-confidence crypto futures signals and auto-execute trades on Binance using our premium Signal Generator.">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
/* === Base Layout === */
body {
  background-color: #f5f7fa;
  color: #1e2022;
  font-family: 'Inter', 'Segoe UI', sans-serif;
  margin: 0;
  padding: 20px;
  line-height: 1.6;
}

/* === Headings === */
h2 {
  color: #1e2022;
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 15px;
}

/* === Signal Card === */
.signal-block {
  background-color: #ffffff;
  border: 1px solid #e2e8f0;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: 0 1px 6px rgba(0, 0, 0, 0.05);
  transition: box-shadow 0.2s ease;
}

.signal-block:hover {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
}

/* === Status Colors === */
.long {
  color: #16a34a; /* Green */
  font-weight: 600;
}

.short {
  color: #dc2626; /* Red */
  font-weight: 600;
}

.neutral {
  color: #6b7280;
}

.profit {
  color: #059669;
}

.loss {
  color: #ef4444;
}

/* === Buttons === */
button,
button[type="submit"],
.trade-btn {
  background-color: #fcd34d; /* Binance Yellow */
  color: #000000;
  border: none;
  padding: 10px 20px;
  font-size: 15px;
  font-weight: 500;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

button:hover,
.trade-btn:hover {
  background-color: #fbbf24;
}
  .tagline {
  font-size: 15px;
  color: #6b7280;
  margin-bottom: 20px;
}
    .marketh2 {
      color: #0088cc;
    }
    
 .pnlh2 {
      color: #FFA500;
    }
    
/* === Form Styling === */
.form-container {
  max-width: 420px;
  margin: 30px auto;
  padding: 24px;
  background-color: #ffffff;
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  text-align: center;
}

/* === Inputs === */
input[type="text"],
input[type="password"] {
  width: 100%;
  padding: 12px;
  margin: 12px 0;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  box-sizing: border-box;
  background-color: #f9fafb;
  color: #111827;
  font-size: 15px;
  outline: none;
  transition: border-color 0.2s;
}

input:focus {
  border-color: #3b82f6;
}

/* === Error Text === */
.error {
  color: #dc2626;
  font-size: 14px;
}
   @keyframes shake {
        0% { transform: rotate(0deg); }
        25% { transform: rotate(10deg); }
        50% { transform: rotate(-10deg); }
        75% { transform: rotate(10deg); }
        100% { transform: rotate(0deg); }
    }

    #premiumIcon {
        position: absolute;
        top: 10px;
        right: 10px;
        font-size: 28px;
        cursor: pointer;
        animation: shake 1.5s infinite;
    }

    #statsIcon {
        position: absolute;
        top: 50px;
        right: 10px;
        font-size: 28px;
        cursor: pointer;
        animation: shake 1.5s infinite;
    }

    #premiumForm {
        display: none;
        border: 2px solid #ffd700;
        border-radius: 12px;
        padding: 15px;
        background-color: #fffbea;
        margin-top: 20px;
        text-align: center;
        max-width: 300px;
        margin-left: auto;
        margin-right: auto;
    }

    #premiumForm h3 {
        margin-bottom: 10px;
    }

    #premiumForm p {
        margin: 5px 0;
    }

    #premiumForm input {
        width: 90%;
        padding: 10px;
        margin-top: 10px;
        margin-bottom: 10px;
        border-radius: 8px;
        border: 1px solid #ccc;
        font-size: 1em;
    }

    #submitBtn {
        background-color: #ffcc00;
        padding: 10px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        font-size: 1em;
    }

    #statusMsg {
        margin-top: 10px;
        font-size: 0.9em;
        color: green;
    }

#scanButton {
  display: none;
      }

  </style>
</head>
<body>
  
<a href="https://t.me/SUAIB235" target="_blank"
   style="position: fixed; bottom: 20px; right: 20px; background-color: #0088cc; color: white; padding: 10px 16px; border-radius: 50px; font-weight: bold; text-decoration: none; box-shadow: 0 4px 10px rgba(0,0,0,0.2);">
  Chat with Admin
</a>

  <div class="form-container" id="loginForm">
    <h2>Login</h2>
    <input type="password" id="password" placeholder="Enter your password">
    <button onclick="login()">Login</button>
    <div class="error" id="loginError"></div>
    <p>Don't have an account? <a href="#" onclick="showSignupForm()">Sign up</a></p>
  </div>

  <div class="form-container" id="signupForm" style="display:none;">
    <h2>Sign Up</h2>
    <input type="password" id="newPassword" placeholder="Enter a password">
    <input type="text" id="chatId" placeholder="Enter Telegram Chat ID">
    <input type="text" id="binanceApi" placeholder="Enter Binance API Key">
    <input type="text" id="binanceSecret" placeholder="Enter Binance Secret Key">
    <button onclick="signup()">Sign Up</button>
    <div class="error" id="signupError"></div>
    <p>Already have an account? <a href="#" onclick="showLoginForm()">Login</a></p>
  </div>

  <!-- Main Content (Hidden until password is correct) -->
  <div id="mainContent" style="display:none;">
    <div id="premiumIcon">ğŸ†</div>
    <div id="statsIcon">ğŸ“Š</div>
    <h1>ğŸš€ Signal Generator</h1>
<p class="tagline">Auto-execute Binance trades with premium crypto signals</p>
  <button id="scanButton" onclick="scan()">Scan Now</button>
  <p id="waitingMessage" style="display: none; color: #f57c00;">Waiting for good market conditions...</p>
  <div id="error-message"></div>
  <div id="statsContainer" style="display: flex; align-items: center; gap: 5px; margin-top: 10px; background-color: #ffffff;
  border: 1px solid #d1d5db; border-radius: 10px; padding: 10px;">
  <span id="futuresBalance" style="font-weight: bold; color: #388e3c;">Balance: ...</span>
  <span id="positionsCount" style="font-weight: bold; color: #4f46e5;">Open: ...</span>
  <span class="pnlh2" id="pnlValue" style="font-weight: bold;">PNL: ...</span>
  <span class="marketh2" id="marketStatus" style="font-weight: bold;">Market: ...</span>
   </div>
   <div id="lastTime" style="margin-bottom:10px; margin-top:10px;"></div>
    <div id="output">Loading...</div>
  </div>

  <div id="premiumForm" style="display: none;">
    <h3>ğŸŒŸ Unlock Premium Access ğŸŒŸ</h3>
    <p>âœ… High-confidence crypto signals</p>
    <p>âœ… Auto-execute Binance trades</p>
    <p>âœ… Priority support & updates</p>
    <p>â° <b>Premium Validity:</b> 30 days</p>
    <p>ğŸ’¸ Send <b>$2</b> to Binance UID: <b>381708407</b></p>
    <p>ğŸ”‘ Your Premium Code:</p>
    <p style="word-break: break-word; font-family: monospace; background-color: #f3f4f6; padding: 8px; border-radius: 6px;" id="deviceCode"></p>

    <input type="text" id="senderUidInput" placeholder="Enter your Binance UID" 
        style="width: 100%; padding: 10px; margin-top: 10px; border-radius: 8px; border: 1px solid #ccc;" />

    <button id="submitBtn" 
        style="margin-top: 10px; padding: 10px 20px; border: none; background-color: #facc15; border-radius: 8px; cursor: pointer;">
        Submit
    </button>

    <p style="margin-top: 10px; font-size: 14px;">
        ğŸ’¬ <a href="https://t.me/SUAIB235" target="_blank" 
            style="text-decoration: none; color: #3b82f6;">
            Premium lost? Contact admin
        </a>
    </p>

    <div id="statusMsg" style="margin-top: 10px; font-size: 14px; color: green;"></div>
  </div>
  
<div id="todayStatsBox" style="display: none; margin-top: 10px; border: 1px solid #ccc; border-radius: 8px; padding: 10px; background-color: #f9f9f9;">
  <strong>ğŸ“Š Todayâ€™s Trade Stats</strong><br>
  Total Trades: <span id="totalTrades">0</span><br>
  TP Hits: <span id="tpHit">0</span><br>
  SL Hits: <span id="slHit">0</span><br>
  Win Rate: <span id="winRate">0%</span>
</div>

  <footer style="text-align:center; font-size:13px; color:#9ca3af; margin-top:40px;">
  Â© 2025 SignalGenerator.store â€” Built for Binance Futures Trading
</footer>

  <script src="env.js"></script>
  <script src="env2.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.js"></script>
  <script>
document.addEventListener("DOMContentLoaded", () => {
  const loginForm = document.getElementById("loginForm");
  const mainContent = document.getElementById("mainContent");
  const sessionValidUntil = localStorage.getItem("sessionValidUntil");
  const now = Date.now();
  const premiumForm = document.getElementById("premiumForm");
  const premiumIcon = document.getElementById("premiumIcon");
  const scanButton = document.getElementById("scanButton");
  const submitBtn = document.getElementById("submitBtn");
  const statusMsg = document.getElementById("statusMsg");

  // Session Login Logic
  if (sessionValidUntil && now < parseInt(sessionValidUntil)) {
    loginForm.style.display = "none";
    mainContent.style.display = "block";
    showError("Welcome back! You're still logged in.");
  } else {
    localStorage.removeItem("sessionValidUntil");
    loginForm.style.display = "block";
    mainContent.style.display = "none";
  }

  // UID Logic
  let uid = localStorage.getItem("uid");
  if (!uid) {
    uid = crypto.randomUUID();
    localStorage.setItem("uid", uid);
  }
  document.getElementById("deviceCode").innerText = uid;

  // Toggle Premium Form
premiumIcon.addEventListener("click", () => {
  const premiumForm = document.getElementById("premiumForm");
  const statsBox = document.getElementById("todayStatsBox");

  // Close stats box if it's open
  if (statsBox && statsBox.style.display === "block") {
    statsBox.style.display = "none";
  }

  // Toggle premium form
  premiumForm.style.display = premiumForm.style.display === "none" ? "block" : "none";
});

// Toggle Stats Box
statsIcon.addEventListener("click", () => {
  const statsBox = document.getElementById("todayStatsBox");
  const premiumForm = document.getElementById("premiumForm");

  // Close premium form if it's open
  if (premiumForm && premiumForm.style.display === "block") {
    premiumForm.style.display = "none";
  }

  // Toggle stats box
  statsBox.style.display = statsBox.style.display === "none" ? "block" : "none";
});

async function updateTradeStats() {
    const startOfToday = new Date();
    startOfToday.setUTCHours(0, 0, 0, 0);
    const startTimestamp = startOfToday.getTime();

    try {
      const trades = await sendSignedRequest("/fapi/v1/userTrades", {
        startTime: startTimestamp,
        timestamp: Date.now() + timeOffset
      });

      let tp = 0;
      let sl = 0;

      trades.forEach(t => {
        const pnl = parseFloat(t.realizedPnl);
        if (pnl > 0.01) tp++;
        else if (pnl < -0.01) sl++;
      });

      const total = tp + sl;
      const winRate = total ? ((tp / total) * 100).toFixed(1) : 0;

      document.getElementById("tpHit").innerText = tp;
      document.getElementById("slHit").innerText = sl;
      document.getElementById("winRate").innerText = `${winRate}%`;
      document.getElementById("totalTrades").innerText = total;

    } catch (err) {
      console.error("Error updating trade stats:", err);
    }
  }

  // Update every minute
  updateTradeStats();
  setInterval(updateTradeStats, 60000);
  
  // Premium Submission to Telegram
  if (submitBtn) {
    submitBtn.addEventListener("click", async () => {
      const senderUid = document.getElementById("senderUidInput").value.trim();
      if (!senderUid) {
        statusMsg.innerText = "â— Please enter your Binance UID.";
        statusMsg.style.color = "red";
        return;
      }

      const message = `ğŸŒŸ *Premium Request* ğŸŒŸ\nDevice Code: \`${uid}\`\nSender UID: ${senderUid}`;
      const telegramUrl = `https://api.telegram.org/bot${window.env2.BOT_TOKEN2}/sendMessage?chat_id=${window.env2.CHAT_ID2}&text=${encodeURIComponent(message)}&parse_mode=Markdown`;

      try {
        await fetch(telegramUrl);
        statusMsg.innerText = "âœ… Submitted! Please wait for admin confirmation.";
        statusMsg.style.color = "green";
      } catch {
        statusMsg.innerText = "âŒ Submission failed. Please try again.";
        statusMsg.style.color = "red";
      }
    });
  }

  // Premium Check
  fetch("premium-uids.json")
    .then((res) => res.json())
    .then((data) => {
      const entry = data.premium.find((p) => p.uid === uid);
      let isPremium = false;

      if (entry) {
        const expiry = new Date(entry.expires);
        isPremium = now < expiry.getTime();

        if (!isPremium) {
          showError("Your premium access has expired.");
        }
      } else {
        showError("Premium access not found.");
      }

      window.isPremium = isPremium;
      toggleScanButton();
    })
    .catch(() => {
      showError("Premium check failed.");
    });

  // Trade Count Watcher
  setInterval(async () => {
    try {
      const count = await getOpenPositionsCount();
      const blocks = document.querySelectorAll(".signal-block");

      if (count >= 10) {
        showError("Limit reached. Avoid overtrading.");
        scanButton.disabled = true;
        blocks.forEach((b) => (b.style.display = "none"));
      } else {
        scanButton.disabled = false;
        blocks.forEach((b) => (b.style.display = "block"));
      }
    } catch (err) {
      console.error("Error checking positions:", err);
    }
  }, 10000);
});

// Login
function login() {
  const password = document.getElementById("password").value;
  const storedPassword = localStorage.getItem("password");
  if (password === storedPassword) {
    const expiresAt = Date.now() + 72 * 60 * 60 * 1000;
    localStorage.setItem("sessionValidUntil", expiresAt);
    document.getElementById("loginForm").style.display = "none";
    document.getElementById("mainContent").style.display = "block";
    showError("Login successful!");
  } else {
    document.getElementById("loginError").textContent = "Incorrect password!";
  }
}

// Signup
function signup() {
  const pw = document.getElementById("newPassword").value;
  const chatId = document.getElementById("chatId").value;
  const api = document.getElementById("binanceApi").value;
  const secret = document.getElementById("binanceSecret").value;

  if (!pw || !chatId || !api || !secret) {
    document.getElementById("signupError").textContent = "All fields are required!";
    return;
  }

  localStorage.setItem("password", pw);
  localStorage.setItem("chatId", chatId);
  localStorage.setItem("binanceApi", api);
  localStorage.setItem("binanceSecret", secret);
  showLoginForm();
  showError("Signup complete. Please login.");
}

// UI Toggling
function showLoginForm() {
  document.getElementById("signupForm").style.display = "none";
  document.getElementById("loginForm").style.display = "block";
}
function showSignupForm() {
  document.getElementById("loginForm").style.display = "none";
  document.getElementById("signupForm").style.display = "block";
}

let scanInterval = null;
let autoScanActive = false;
    
    const cooldowns = {};
    const COOLDOWN_MINUTES = 60;
    const output = document.getElementById("output");
    const lastTime = document.getElementById("lastTime");

async function getPrecisionInfo(symbol) {
  const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
  const data = await res.json();
  const symbolInfo = data.symbols.find(s => s.symbol === symbol);
  if (!symbolInfo) throw new Error('Symbol not found');

  const priceFilter = symbolInfo.filters.find(f => f.filterType === "PRICE_FILTER");
  const lotSize = symbolInfo.filters.find(f => f.filterType === "LOT_SIZE");

  const pricePrecision = Math.round(-Math.log10(parseFloat(priceFilter.tickSize)));
  const quantityPrecision = Math.round(-Math.log10(parseFloat(lotSize.stepSize)));

  return { pricePrecision, quantityPrecision };
}

    async function scan(autoTriggered = false) {
  if (!autoTriggered) {
    clearInterval(scanInterval); // Reset interval when manually scanning
    autoScanActive = true;
    scanInterval = setInterval(() => scan(true), 15000); // Run every 15s
  }

  output.innerHTML = "Scanning...";
  const res = await fetch("https://fapi.binance.com/fapi/v1/ticker/price");
  const coins = await res.json();
  const usdtPairs = coins.filter(c => c.symbol.endsWith("USDT") && !c.symbol.includes("_"));
  const results = await Promise.all(usdtPairs.map(c => analyzeSymbol(c.symbol)));
  const filtered = results.filter(r => r);
  output.innerHTML = filtered.length > 0 ? filtered.join("") : "No strong signals found.";
  lastTime.innerText = "Last scanned: " + new Date().toLocaleTimeString();

  if (filtered.length > 0 && autoScanActive) {
    clearInterval(scanInterval);
    autoScanActive = false;
  }

  return filtered.length > 0;
}

       async function analyzeSymbol(symbol) {
  try {
    const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=5m&limit=100`;
    const res = await fetch(url);
    const data = await res.json();

    const closes = data.map(c => parseFloat(c[4]));
    const opens = data.map(c => parseFloat(c[1]));
    const highs = data.map(c => parseFloat(c[2]));
    const lows = data.map(c => parseFloat(c[3]));
    const volumes = data.map(c => parseFloat(c[5]));

    const ema9 = calculateEMA(closes, 9);
    const ema21 = calculateEMA(closes, 21);
    const rsi = calculateRSI(closes, 14);
    const { macd, signal } = calculateMACD(closes);
    const atr = calculateATR(highs, lows, closes, 14);

    if (!ema9.length || !ema21.length || !rsi.length || !macd.length || !signal.length || !atr.length) {
      throw new Error("Insufficient indicator data.");
    }

    const lastClose = closes.at(-1);
    const lastOpen = opens.at(-1);
    const lastHigh = highs.at(-1);
    const lastLow = lows.at(-1);
    const lastVol = volumes.at(-1);
    const avgVol = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;

    const latestEma9 = ema9.at(-1);
    const latestEma21 = ema21.at(-1);
    const latestRsi = rsi.at(-1);
    const latestMacd = macd.at(-1);
    const latestSignal = signal.at(-1);
    const latestAtr = atr.at(-1) || 0;
    const macdHistogram = latestMacd - latestSignal;

    const candleStrength = (lastClose - lastOpen) / lastClose;
    const wickRatio = (lastHigh - lastLow) / lastClose;

    // Config
    const THRESHOLDS = {
      rsiLong: 55,
      rsiShort: 45,
      macdPositive: 0.0,
      macdNegative: 0.0,
      volMultiplier: 1.5,
      candleStrengthMin: 0.002,
      wickRatioMax: 0.02,
      minConfirmCandles: 2
    };

    // Recent candles
    const recentOpens = opens.slice(-3);
    const recentCloses = closes.slice(-3);
    const recentBullishCount = recentCloses.filter((c, i) => c > recentOpens[i]).length;
    const recentBearishCount = recentCloses.filter((c, i) => c < recentOpens[i]).length;

    const dynamicCandleStrength = Math.max(THRESHOLDS.candleStrengthMin, latestAtr * 0.0015);
    const dynamicVolumeThreshold = avgVol * THRESHOLDS.volMultiplier;

    let score = 0, shortScore = 0;
    let scoreReasons = [], shortScoreReasons = [];

if (latestEma9 > latestEma21) { score += 1; scoreReasons.push("EMA9 > EMA21"); }
if (latestRsi > THRESHOLDS.rsiLong) { score += 1; scoreReasons.push("RSI > 55"); }
if (macdHistogram > THRESHOLDS.macdPositive) { score += 1; scoreReasons.push("MACD > 0"); }
if (lastVol > dynamicVolumeThreshold) { score += 1; scoreReasons.push("Volume > Avg * 1.5"); }
if (candleStrength > dynamicCandleStrength) { score += 1; scoreReasons.push("Candle Strength > Threshold"); }
if (wickRatio < THRESHOLDS.wickRatioMax) { score += 1; scoreReasons.push("Wick Ratio < 0.02"); }
if (recentBullishCount >= THRESHOLDS.minConfirmCandles) { score += 1; scoreReasons.push("2+ Bullish Candles"); }

if (latestEma9 < latestEma21) { shortScore += 1; shortScoreReasons.push("EMA9 < EMA21"); }
if (latestRsi < THRESHOLDS.rsiShort) { shortScore += 1; shortScoreReasons.push("RSI < 45"); }
if (macdHistogram < THRESHOLDS.macdNegative) { shortScore += 1; shortScoreReasons.push("MACD < 0"); }
if (lastVol > dynamicVolumeThreshold) { shortScore += 1; shortScoreReasons.push("Volume > Avg * 1.5"); }
if (candleStrength < -dynamicCandleStrength) { shortScore += 1; shortScoreReasons.push("Candle Strength Negative"); }
if (wickRatio < THRESHOLDS.wickRatioMax) { shortScore += 1; shortScoreReasons.push("Wick Ratio < 0.02"); }
if (recentBearishCount >= THRESHOLDS.minConfirmCandles) { shortScore += 1; shortScoreReasons.push("2+ Bearish Candles"); }

let signalType = null;
let confidence = "None";
let reasons = [];

if (score >= 7) {
  signalType = "LONG";
  confidence = "Very High";
  reasons = scoreReasons;
} else if (shortScore >= 7) {
  signalType = "SHORT";
  confidence = "Very High";
  reasons = shortScoreReasons;
} else if (score === 6) {
  signalType = "LONG";
  confidence = "High";
  reasons = scoreReasons;
} else if (shortScore === 6) {
  signalType = "SHORT";
  confidence = "High";
  reasons = shortScoreReasons;
}

if (signalType && symbol) {
          const now = Date.now();
          const lastSignalTime = cooldowns[symbol] || 0;
          if (now - lastSignalTime < COOLDOWN_MINUTES * 60 * 1000) return null;
          cooldowns[symbol] = now;
  
if (marketCondition !== "GOOD") {
  console.log("Signal skipped: Market condition is not GOOD.");
  return null;
}

if (nearPullback) {
  console.log("Signal skipped: BTC is near a potential pullback zone.");
  return null;
}

if ((btcTrend === "bullish" && signalType === "SHORT") ||
    (btcTrend === "bearish" && signalType === "LONG")) {
  console.log(`Signal skipped: BTC is ${btcTrend}, signal direction is ${signalType}`);
  return null;
}

const price = lastClose; 
const atrMultiplier = 2.0; // You can tune this
const rrRatio = 1.2; // Risk\:Reward
const minSlPercent = 0.005; // 0.5%

let sl, tp;

const rawSl = signalType === "LONG"
Â  ? price - latestAtr * atrMultiplier
Â  : price + latestAtr * atrMultiplier;

const minSl = price * minSlPercent;

// Ensure SL is not too tight
sl = signalType === "LONG"
Â  ? Math.min(price - minSl, rawSl)
Â  : Math.max(price + minSl, rawSl);

// Calculate TP based on SL distance (risk-reward logic)
const risk = Math.abs(price - sl);
tp = signalType === "LONG"
Â  ? (price + risk * rrRatio)
Â  : (price - risk * rrRatio);

// Format to 5 decimals (adjust if needed for token precision)
sl = sl.toFixed(5);
tp = tp.toFixed(5);

const escapedReasons = reasons.map(r =>
  r.replace(/&/g, '&amp;')
   .replace(/</g, '&lt;')
   .replace(/>/g, '&gt;')
).join('\n');

const telegramMessage = `
<b>ğŸš¨ Signal Alert </b>Â Â 
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”Â Â 
<b>ğŸ“Š Pair:</b> <code>${symbol}</code>Â Â 
<b>ğŸ“‰ Position:</b> <b><code>${signalType}</code></b>Â Â 
<b>ğŸ¯ Entry:</b> <code>${price.toFixed(5)}</code>Â Â 
<b>â­ Take Profit:</b> <code>${tp}</code>Â Â 
<b>â›” Stop Loss:</b> <code>${sl}</code>Â Â 
<b>âš™ï¸ Leverage:</b> <code>10x â€“ 20x</code>Â Â 
<b>ğŸ”’ Confidence:</b> <code>${confidence}</code>Â Â 
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”Â Â 
<b>ğŸ§ª Matched Rules:</b>Â Â 
<pre>${escapedReasons}</pre>

<b>ğŸ§  Strategy:</b>Â Â 
<i>SL is mandatory. Always apply position sizing and risk management.</i>Â Â 

<b>ğŸ” Source:</b> <i>High-confluence algo strategy</i>
`;

await sendToTelegram(telegramMessage);


          return `
<div class="signal-block">
  <b>ğŸ“Š Symbol:</b> ${symbol}<br>
  <b>ğŸš¨ SIGNAL:</b> <span class="${signalType === "LONG" ? "long" : "short"}">${signalType}</span><br>
  <b>ğŸ’° Entry:</b> ${price.toFixed(5)}<br>
  <b>â­ TP:</b> ${tp}<br>
  <b>â›” SL:</b> ${sl}<br>
  <b>âš™ï¸ Leverage:</b> ${confidence === "High" ? "20x (or max)" : "10â€“20x"}<br>
  <b>âœ… Confidence:</b> <code>${confidence} (score: ${signalType === "LONG" ? score : shortScore})</code>
  <button class="trade-btn" onclick="placeTrade('${symbol}', '${signalType === "LONG" ? "BUY" : "SELL"}', '${price.toFixed(5)}', '${tp}', '${sl}')">Trade</button>
  </div>`;
        }
      } catch (err) {
        console.error("Error analyzing", symbol, err);
        return null;
      }
    }

    function calculateEMA(closes, period) {
      const k = 2 / (period + 1);
      let ema = [closes[0]];
      for (let i = 1; i < closes.length; i++) {
        ema.push(closes[i] * k + ema[i - 1] * (1 - k));
      }
      return ema;
    }

    function calculateRSI(closes, period) {
      let gains = 0, losses = 0;
      for (let i = 1; i <= period; i++) {
        let diff = closes[i] - closes[i - 1];
        if (diff >= 0) gains += diff;
        else losses -= diff;
      }
      let rs = gains / losses;
      let rsi = [100 - 100 / (1 + rs)];

      for (let i = period + 1; i < closes.length; i++) {
        let diff = closes[i] - closes[i - 1];
        if (diff >= 0) {
          gains = (gains * (period - 1) + diff) / period;
          losses = (losses * (period - 1)) / period;
        } else {
          gains = (gains * (period - 1)) / period;
          losses = (losses * (period - 1) - diff) / period;
        }
        rs = gains / losses;
        rsi.push(100 - 100 / (1 + rs));
      }
      return rsi;
    }

    function calculateATR(highs, lows, closes, period) {
      let trs = [];
      for (let i = 1; i < highs.length; i++) {
        const tr = Math.max(
          highs[i] - lows[i],
          Math.abs(highs[i] - closes[i - 1]),
          Math.abs(lows[i] - closes[i - 1])
        );
        trs.push(tr);
      }
      const atr = [trs.slice(0, period).reduce((a, b) => a + b, 0) / period];
      for (let i = period; i < trs.length; i++) {
        atr.push((atr[atr.length - 1] * (period - 1) + trs[i]) / period);
      }
      return atr;
    }

    function calculateMACD(closes) {
  const ema12 = calculateEMA(closes, 12);
  const ema26 = calculateEMA(closes, 26);

  const macd = ema12.slice(ema26.length - ema12.length).map((v, i) => v - ema26[i]);
  const signal = calculateEMA(macd, 9);

  return { macd, signal };
}

  
function getBinanceCredentials() {
  return {
    apiKey: localStorage.getItem('binanceApi'),
    secretKey: localStorage.getItem('binanceSecret')
  };
}

function getTelegramCredentials() {
  return {
    chatId: localStorage.getItem('chatId')
  };
}
  
    async function sendToTelegram(message) {
      const { chatId } = getTelegramCredentials();
      const botToken = window.env.BOT_TOKEN;
      
      await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ chat_id: chatId, text: message, parse_mode: "HTML" })
      });
    }

const { apiKey: binanceKey, secretKey: binanceSecret } = getBinanceCredentials();
 
async function placeTrade(symbol, side, entry, tp, sl) {
  try {
    const { pricePrecision, quantityPrecision } = await getPrecisionInfo(symbol);
    const quantity = await getQuantity(symbol, entry, quantityPrecision);
    const leverage = await getSafeLeverage(symbol);

    await setLeverage(symbol, leverage);

    const adjustedPrice = parseFloat(entry).toFixed(pricePrecision);
    const response = await sendLimit(symbol, side, quantity, adjustedPrice, tp, sl, false, pricePrecision, quantityPrecision);

    if (!response || response.code) {
      console.error("Error placing order:", response ? response.msg : "Unknown error");
      showError("Error placing order.");
    }
  } catch (error) {
    console.error("Error in placeTrade function:", error);
    showError("An error occurred while placing the trade.");
  }
}

let isWindowActive = true;
window.addEventListener("beforeunload", () => {
  isWindowActive = false;
});

async function sendLimit(symbol, side, qty, price, tp, sl, reduceOnly, pricePrecision, quantityPrecision) {
  if (!isWindowActive) {
    console.warn("Window inactive. Order not sent.");
    return;
  }

  try {
    const orderParams = {
      symbol: symbol,
      side: side,
      positionSide: side === 'BUY' ? 'LONG' : 'SHORT',
      type: 'MARKET',
      quantity: parseFloat(parseFloat(qty).toFixed(quantityPrecision)),
      timestamp: Date.now()
    };

    if (reduceOnly) orderParams.reduceOnly = true;

    const response = await sendSignedRequest('/fapi/v1/order', orderParams, "POST");
    console.log("Order response:", response);

    if (response && !response.code) {
      const positionSide = side === 'BUY' ? 'LONG' : 'SHORT';
      const oppositeSide = side === 'BUY' ? 'SELL' : 'BUY';

      // TAKE PROFIT
      try {
        await sendSignedRequest('/fapi/v1/order', {
          symbol,
          side: oppositeSide,
          type: 'TAKE_PROFIT_MARKET',
          stopPrice: parseFloat(tp).toFixed(pricePrecision),
          closePosition: true,
          positionSide,
          priceProtect: true,
          timestamp: Date.now()
        }, "POST");
        console.log("âœ… TP set for", symbol);
      } catch (tpErr) {
        console.error("âŒ TP error for", symbol, tpErr);
        showError(`Failed to set TP for ${symbol}`);
      }

      // STOP LOSS
      try {
        await sendSignedRequest('/fapi/v1/order', {
          symbol,
          side: oppositeSide,
          type: 'STOP_MARKET',
          stopPrice: parseFloat(sl).toFixed(pricePrecision),
          closePosition: true,
          positionSide,
          priceProtect: true,
          timestamp: Date.now()
        }, "POST");
        console.log("âœ… SL set for", symbol);
      } catch (slErr) {
        console.error("âŒ SL error for", symbol, slErr);
        showError(`Failed to set SL for ${symbol}`);
      }
    }

    return response;

  } catch (mainErr) {
    console.error("âŒ Order error:", mainErr);
    showError(`Order failed for ${symbol}`);
    return null;
  }
}

    async function setLeverage(symbol, lev) {
      return sendSignedRequest('/fapi/v1/leverage', {
        symbol,
        leverage: lev,
        timestamp: Date.now()
      }, "POST");
    }

    async function getSafeLeverage(symbol) {
  const res = await sendSignedRequest('/fapi/v1/leverageBracket', {}, 'GET');
  
  // res is an array of objects with symbol and brackets
  const pair = res.find(p => p.symbol === symbol);

  if (!pair || !pair.brackets || pair.brackets.length === 0) {
    console.warn(`Leverage bracket not found for ${symbol}`);
    return 10; // default fallback leverage
  }

  const maxLeverage = pair.brackets[0].initialLeverage;
  return Math.min(maxLeverage, 20);
}
    
  async function getQuantity(symbol, price, quantityPrecision) {
  const usdt = window.env.TRADE_USDT; // USDT amount to use
  const qty = usdt / parseFloat(price);
  return parseFloat(qty).toFixed(quantityPrecision);
    }

async function getBTCIndicators() {
  const res = await fetch("https://fapi.binance.com/fapi/v1/klines?symbol=BTCUSDT&interval=5m&limit=200");
  const data = await res.json();

  const closes = data.map(c => parseFloat(c[4]));
  const volumes = data.map(c => parseFloat(c[5]));

  const ema50 = getEMA(closes, 50);
  const ema200 = getEMA(closes, 200);
  const currentVolume = volumes[volumes.length - 1];
  const avgVolume = volumes.slice(-30).reduce((a, b) => a + b, 0) / 30;

  const priceNow = closes[closes.length - 1];
  const priceBefore = closes[closes.length - 6]; // ~25 minutes ago
  const priceRising = priceNow > priceBefore;

  let trend = "bearish";
  if (ema50[ema50.length - 1] > ema200[ema200.length - 1] && priceRising) {
    trend = "bullish";
  }

  // Debug output
  console.log(`BTC Trend: ${trend}`);
  console.log(`EMA50: ${ema50[ema50.length - 1].toFixed(2)} | EMA200: ${ema200[ema200.length - 1].toFixed(2)}`);
  console.log(`Price Now: ${priceNow} | Price 25min ago: ${priceBefore}`);
  console.log(`Volume: ${currentVolume} | AvgVolume(30): ${avgVolume}`);

  return {
    ema50: ema50[ema50.length - 1],
    ema200: ema200[ema200.length - 1],
    currentVolume,
    avgVolume,
    trend
  };
}

function getEMA(prices, period) {
  const k = 2 / (period + 1);
  const ema = [prices.slice(0, period).reduce((a, b) => a + b, 0) / period];

  for (let i = period; i < prices.length; i++) {
    ema.push(prices[i] * k + ema[ema.length - 1] * (1 - k));
  }

  return ema;
}

let marketCondition = "BAD";
let btcTrend = "bearish";
let nearPullback = false;

async function updateMarketCondition() {
  const { ema50, ema200, currentVolume, avgVolume, trend } = await getBTCIndicators();

  const emaGap = Math.abs(ema50 - ema200) / ema200;
  const trendOkay = emaGap > 0.002;
  const noVolumeSpike = currentVolume < avgVolume * 1.8;

  marketCondition = (trendOkay && noVolumeSpike) ? "GOOD" : "BAD";
  btcTrend = trend;

  nearPullback = emaGap > 0.01;
  console.log(`Near Pullback: ${nearPullback}`);

  const statusEl = document.getElementById("marketStatus");
  if (statusEl) {
    
    if ((marketCondition === "GOOD" && btcTrend === "bearish") || (marketCondition === "BAD" && btcTrend === "bullish")) {
      const marketColor = marketCondition === "GOOD" ? "#388e3c" : "#d32f2f";
      const trendColor = btcTrend === "bullish" ? "#388e3c" : "#d32f2f";

      statusEl.innerHTML = `Market: <span style="color:${marketColor}">${marketCondition}</span> (<span style="color:${trendColor}">${btcTrend.toUpperCase()}</span>)`;
    } else {
      
      const color = (marketCondition === "GOOD" && btcTrend === "bullish") ? "#388e3c" : "#d32f2f";
      statusEl.textContent = `Market: ${marketCondition} (${btcTrend.toUpperCase()})`;
      statusEl.style.color = color;
    }
  }

  toggleScanButton();
}

updateMarketCondition();
setInterval(updateMarketCondition, 25000); // Update every 25s

function toggleScanButton() {
  const scanButton = document.getElementById("scanButton");
  const waitingMessage = document.getElementById("waitingMessage");

  if (isPremium && marketCondition === "GOOD" && !nearPullback) {
    scanButton.style.display = "inline-block";
    waitingMessage.style.display = "none";
  } else {
    scanButton.style.display = "none";
    waitingMessage.style.display = isPremium ? "block" : "none";
  }
}

 window.onload = async () => {
  const balance = await getFuturesBalance();
  document.getElementById("futuresBalance").textContent = `Balance: $${balance}`;

  const positionCount = await getOpenPositionsCount();
  document.getElementById("positionsCount").textContent = `Open: ${positionCount}`;

  const pnl = await getTodayPnL();
  document.getElementById("todayPnl").textContent = `PnL: ${pnl >= 0 ? "+" : ""}$${pnl.toFixed(2)}`;
};
    
async function getFuturesBalance() {
  const data = await sendSignedRequest("/fapi/v2/account");
  const usdtAsset = data.assets.find(a => a.asset === "USDT");
  return usdtAsset ? parseFloat(usdtAsset.availableBalance).toFixed(2) : "0.00";
}

async function getOpenPositionsCount() {
  const positions = await sendSignedRequest("/fapi/v2/positionRisk");
  const openPositions = positions.filter(p => parseFloat(p.positionAmt) !== 0);
  return openPositions.length;
}

async function getTodayPnL() {
  try {
    // Get UTC midnight timestamp
    const startOfToday = new Date();
    startOfToday.setUTCHours(0, 0, 0, 0);
    const startTimestamp = startOfToday.getTime();

    // Fetch realized PNL entries from Binance
    const incomeData = await sendSignedRequest("/fapi/v1/income", {
      incomeType: "REALIZED_PNL",
      startTime: startTimestamp,
      limit: 1000
    });

    // Filter for today's entries only (UTC)
    const today = new Date().toISOString().split("T")[0];
    const todayPnl = incomeData
      .filter(entry => {
        const entryDate = new Date(entry.time).toISOString().split("T")[0];
        return entry.incomeType === "REALIZED_PNL" && entryDate === today;
      })
      .reduce((sum, entry) => sum + parseFloat(entry.income), 0);

    // Display
    const pnlElement = document.getElementById("pnlValue");
    pnlElement.textContent = `PNL: ${todayPnl >= 0 ? '+' : ''}${todayPnl.toFixed(2)}`;

    pnlElement.className =
      todayPnl > 0 ? 'profit' :
      todayPnl < 0 ? 'loss' :
      'neutral';

    return todayPnl;
  } catch (error) {
    console.error("Error fetching today's PnL:", error);
    showError("Failed to fetch PNL");
  }
} 
    
let timeOffset = 0;

// Sync local time with Binance server
async function syncServerTime() {
  try {
    const res = await fetch("https://fapi.binance.com/fapi/v1/time");
    const data = await res.json();
    const localTime = Date.now();
    timeOffset = data.serverTime - localTime;
    console.log("Time offset (ms):", timeOffset);
  } catch (err) {
    console.warn("Failed to sync Binance time.");
  }
}

syncServerTime(); // Call once at load
setInterval(syncServerTime, 10 * 60 * 1000); // Re-sync every 10 mins
  
Â  Â  async function sendSignedRequest(path, params = {}, method = "GET") {
  // Add recvWindow and timestamp
  params.recvWindow = 10000; // 5 seconds tolerance
  params.timestamp = Date.now() + timeOffset;

  const query = new URLSearchParams(params).toString();
  const signature = CryptoJS.HmacSHA256(query, binanceSecret).toString(CryptoJS.enc.Hex);

  const fullUrl = `https://fapi.binance.com${path}?${query}&signature=${signature}`;
  const options = {
    method,
    headers: { 'X-MBX-APIKEY': binanceKey }
  };

  // Handle both GET and POST requests
  return fetch(fullUrl, options).then(async r => {
    const data = await r.json();
    if (!r.ok) {
      console.error("Binance API error:", data);
      showError(`Binance Error: ${data.msg || "Unknown error"}`);
    }
    return data;
  });
}

function showError(msg) {
  const box = document.createElement('div');
  box.textContent = msg;
  box.style.cssText = `
      position:fixed; top:20px; left:50%; transform:translateX(-50%);
      max-width:90%; padding:14px 18px;
      background:#ff4444; color:#fff; font-family:monospace;
      border-radius:8px; z-index:9999;
  `;
  document.body.appendChild(box);
  setTimeout(()=> box.remove(), 5000);  // disappear after 5â€¯s
}

    async function refreshStatsAndMarket() {
  try {
    const balance = await getFuturesBalance();
    document.getElementById("futuresBalance").textContent = `Balance: $${balance}`;

    const positionCount = await getOpenPositionsCount();
    document.getElementById("positionsCount").textContent = `Open: ${positionCount}`;

    const pnl = await getTodayPnL();
    document.getElementById("todayPnl").textContent = `PnL: ${pnl >= 0 ? "+" : ""}$${pnl.toFixed(2)}`;

    console.log("Refreshed at:", new Date().toLocaleTimeString());
  } catch (err) {
    console.error("Error during refresh:", err);
  }
}

window.onload = () => {
  refreshStatsAndMarket(); // initial call
  setInterval(refreshStatsAndMarket, 60000); // auto-refresh every 1 min
};
    
  </script>
</body>
  </html>
