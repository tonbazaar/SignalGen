<!DOCTYPE html>
<html>
<head>
  <title>Crypto Futures Signal Generator | Auto Trade with Binance API</title>
  <link rel="icon" type="image/png" href="/favicon_512x512.png">
  <meta name="description" content="Generate high-confidence crypto futures signals and auto-execute trades on Binance using our premium Signal Generator.">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">
  <style>
/* === Base Layout === */
body {
  background-color: #0d1117;
  color: #e6edf3;
  font-family: 'Inter', 'Segoe UI', sans-serif;
  margin: 0;
  padding: 20px;
  line-height: 1.6;
}

/* === Headings === */
h2 {
  color: #e6edf3;
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 15px;
}

/* === Signal Card === */
.signal-block {
  background-color: #161b22;
  border: 1px solid #30363d;
  border-radius: 12px;
  padding: 20px;
  margin-bottom: 20px;
  box-shadow: 0 1px 6px rgba(0, 0, 0, 0.05);
  transition: box-shadow 0.2s ease;
}

.signal-block:hover {
  box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
}

/* === Status Colors === */
.long {
  color: #22c55e; /* Green */
  font-weight: 600;
}

.short {
  color: #ef4444; /* Red */
  font-weight: 600;
}

.neutral {
  color: #94a3b8;
}

.profit {
  color: #22c55e;
}

.loss {
  color: #b91c1c;
}

/* === Buttons === */
button,
button[type="submit"],
.trade-btn {
  background-color: #facc15; /* Binance Yellow */
  color: #0d1117;
  border: none;
  padding: 10px 20px;
  font-size: 15px;
  font-weight: 500;
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

button:hover,
.trade-btn:hover {
  background-color: #eab308;
}
  .tagline {
  font-size: 15px;
  color: #94a3b8;
  margin-bottom: 20px;
}
    
/* === Form Styling === */
.form-container {
  max-width: 420px;
  margin: 30px auto;
  padding: 24px;
  background-color: #161b22;
  border: 1px solid #30363d;
  border-radius: 12px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  text-align: center;
}

/* === Inputs === */
input[type="text"],
input[type="password"] {
  width: 100%;
  padding: 12px;
  margin: 12px 0;
  border: 1px solid #30363d;
  border-radius: 8px;
  box-sizing: border-box;
  background-color: #0d1117;
  color: #e6edf3;
  font-size: 15px;
  outline: none;
  transition: border-color 0.2s;
}

input:focus {
  border-color: #3b82f6;
}

.flying {
  display: inline-block;
  position: relative;
  animation: flyUp 1.5s infinite ease-in-out;
}

@keyframes flyUp {
  0% {
    top: 0;
    opacity: 1;
  }
  50% {
    top: -10px;
    opacity: 0.8;
  }
  100% {
    top: 0;
    opacity: 1;
  }
}

/* === Error Text === */
.error {
  color: #dc2626;
  font-size: 14px;
}

    #settingsIcon, #premiumIcon, 
#statsIcon {
  position: absolute;
  top: 10px;
  font-size: 22px;
  padding: 10px;
  border-radius: 50%;
  cursor: pointer;
  transition: transform 0.2s ease, background-color 0.3s ease;
}

#settingsIcon {
  right: 10px;
  color: #22c55e; /* Green */
}
    
#premiumIcon {
  right: 50px;
  color: #facc15; /* gold/yellow */
}

#statsIcon {
  right: 90px;
  color: #60a5fa; /* blue */
}

#settingsIcon:hover, #premiumIcon:hover,
#statsIcon:hover {
  transform: scale(1.2);
  background-color: rgba(255, 255, 255, 0.1); /* subtle glow on dark */
}

    #settingsModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 999;
}

#settingsContent {
  background: #1e1e1e;
  padding: 20px;
  border-radius: 10px;
  width: 300px;
  text-align: center;
  color: white;
}

#settingsContent input {
  width: 100%;
  padding: 10px;
  margin-top: 10px;
  margin-bottom: 10px;
  border: none;
  border-radius: 5px;
}

#settingsContent button {
  padding: 10px 20px;
  background-color: #3b82f6;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
}

a {
  color: #60a5fa; /* Tailwind blue-400 */
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

#scanButton {
  display: none;
      }

  </style>
</head>
<body>
  
<a href="https://t.me/SUAIB235" target="_blank"
   style="position: fixed; bottom: 20px; right: 20px; background-color: #1d9bf0; color: #e6edf3; padding: 10px 16px; border-radius: 50px; font-weight: bold; text-decoration: none; box-shadow: 0 4px 10px rgba(0,0,0,0.2); display: flex; align-items: center; gap: 8px;">
  <i class="fab fa-telegram-plane"></i> Chat with Admin
</a>

  <div class="form-container" id="loginForm">
    <h2>Login</h2>
    <input type="password" id="password" placeholder="Enter your password">
    <button onclick="login()">Login</button>
    <div class="error" id="loginError"></div>
    <p>Don't have an account? <a href="#" onclick="showSignupForm()">Sign up</a></p>
  </div>

  <div class="form-container" id="signupForm" style="display:none;">
    <h2>Sign Up</h2>
    <input type="password" id="newPassword" placeholder="Enter a password">
    <input type="text" id="chatId" placeholder="Enter Telegram Chat ID">
    <input type="text" id="binanceApi" placeholder="Enter Binance API Key">
    <input type="text" id="binanceSecret" placeholder="Enter Binance Secret Key">
    <button onclick="signup()">Sign Up</button>
    <div class="error" id="signupError"></div>
    <p>Already have an account? <a href="#" onclick="showLoginForm()">Login</a></p>
  </div>

  <!-- Main Content (Hidden until password is correct) -->
  <div id="mainContent" style="display:none;">
  <i id="settingsIcon" class="fas fa-cog" title="Settings"></i>
  <i id="premiumIcon" class="fas fa-crown" title="Unlock Premium"></i>
  <i id="statsIcon" class="fas fa-chart-bar" title="View Stats"></i>
  <h1 id="rocketIcon"><span class="flying">🚀</span> Signal Generator</h1>
  <p class="tagline">Auto-execute Binance trades with premium crypto signals</p>
  <button id="scanButton" onclick="scan()">Scan Now</button>
  <p id="waitingMessage" style="display: none; color: #f59e0b;">Caution: Market unstable or nearing pullback zone...</p>
  <div id="error-message"></div>
  <div id="statsContainer" style="
  display: flex; 
  flex-wrap: wrap;
  justify-content: space-between; 
  gap: 10px; 
  margin-top: 15px; 
  background-color: #161b22;
  border: 1px solid #30363d; 
  border-radius: 12px; 
  padding: 12px;
  font-size: 16px;
">
  <span id="futuresBalance" style="font-weight: bold; color: #22c55e; display: flex; align-items: center; gap: 6px;">
    <i class="fas fa-wallet"></i> <span class="value">...</span>
  </span>

  <span id="positionsCount" style="font-weight: bold; color: #3b82f6; display: flex; align-items: center; gap: 6px;">
    <i class="fas fa-chart-line"></i> <span class="value">...</span>
  </span>

  <span id="pnlValue" style="font-weight: bold; color: #facc15; display: flex; align-items: center; gap: 6px;">
    <i class="fas fa-dollar-sign"></i> <span class="value">...</span>
  </span>

  <span id="marketStatus" style="font-weight: bold; color: #22c55e; display: flex; align-items: center; gap: 6px;">
    <i class="fas fa-signal"></i> <span class="value">...</span>
  </span>

  <span id="pullbackStatus" style="font-weight: bold; color: #f97316; display: flex; align-items: center; gap: 6px;">
  <i class="fas fa-exclamation-triangle"></i> <span class="value">...</span>
</span>

</div>

   <div id="lastTime" style="margin-bottom:10px; margin-top:10px;"></div>
    <div id="output">Loading...</div>
  </div>

  <div id="premiumForm" style="
  display: none;
  background-color: #161b22;
  border: 1px solid #30363d;
  border-radius: 12px;
  padding: 20px;
  color: #e6edf3;
  max-width: 360px;
  margin: 24px auto;
  box-shadow: 0 2px 12px rgba(0, 0, 0, 0.35);
  text-align: center;
">

  <h3 style="font-size: 18px; font-weight: 600; margin-bottom: 16px;">
    <i class="fas fa-crown" style="color: #facc15; margin-right: 6px;"></i> Unlock Premium Access
  </h3>

  <div style="text-align: left; font-size: 15px; margin-bottom: 16px; line-height: 1.6;">
    <p>✅ High-confidence crypto signals</p>
    <p>✅ Auto-execute Binance trades</p>
    <p>✅ Priority support & updates</p>
    <p>⏰ <strong>Premium Validity:</strong> 30 days</p>
    <p>💸 Send <strong>$5</strong> to Binance UID: <strong>381708407</strong></p>
    <p>🔑 <strong>Your Premium Code:</strong></p>
    <p id="deviceCode" style="
      word-break: break-word;
      font-family: monospace;
      background-color: #1f2937;
      border: 1px solid #30363d;
      padding: 8px 12px;
      border-radius: 6px;
      color: #facc15;
      font-size: 14px;
    "></p>
  </div>

  <input type="text" id="senderUidInput" placeholder="Enter your Binance UID"
    style="width: 100%; padding: 10px; margin-top: 4px; margin-bottom: 10px;
           border-radius: 8px; border: 1px solid #30363d;
           background-color: #0d1117; color: #e6edf3; font-size: 14px;" />

  <button id="submitBtn"
    style="margin-top: 8px; padding: 10px 20px; border: none;
           background-color: #facc15; color: #0d1117;
           border-radius: 8px; font-weight: 600; cursor: pointer;">
    Submit
  </button>

  <p style="margin-top: 12px; font-size: 14px;">
    💬 <a href="https://t.me/SUAIB235" target="_blank"
         style="color: #60a5fa; text-decoration: none;">
      Premium lost? Contact admin
    </a>
  </p>

  <div id="statusMsg" style="margin-top: 10px; font-size: 14px; color: #22c55e;"></div>
</div>

  <div id="premiumStatusBox" style="
  display: none;
  position: fixed;
  top: 80px;
  right: 20px;
  background-color: #161b22;
  border: 1px solid #30363d;
  border-radius: 10px;
  padding: 16px;
  color: #e6edf3;
  z-index: 1000;
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  max-width: 280px;
  font-size: 14px;
"></div>
  
<div id="todayStatsBox" style="
  display: none;
  margin-top: 16px;
  padding: 16px 20px;
  border-radius: 12px;
  background-color: #161b22;
  border: 1px solid #30363d;
  color: #e6edf3;
  font-size: 15px;
  box-shadow: 0 2px 10px rgba(0,0,0,0.3);
  max-width: 320px;
  margin-left: auto;
  margin-right: auto;
">
  <div style="font-weight: 600; font-size: 16px; margin-bottom: 10px;">
    <i class="fas fa-chart-line" style="color: #60a5fa; margin-right: 6px;"></i>
    Today’s Trade Stats
  </div>
  <div>Total Trades: <strong id="totalTrades">0</strong></div>
  <div>TP Hits: <strong id="tpHit">0</strong></div>
  <div>SL Hits: <strong id="slHit">0</strong></div>
  <div>Win Rate: <strong id="winRate">0%</strong></div>
</div>

<div id="settingsModal" style="display: none;">
  <div id="settingsContent">
    <h3>Set Trade Amount</h3>
    <label for="usdtInput">Enter USDT amount:</label>
    <input type="number" id="usdtInput" placeholder="e.g. 20" />
    <p id="calculatedMargin">Margin: 0 USDT</p>
    <button id="saveSettings">Submit</button>
  </div>
</div>

  <footer style="text-align:center; font-size:13px; color:#8b949e; margin-top:40px;">
  © 2025 SignalGenerator.store — Built for Binance Futures Trading
</footer>

  <script src="env.js"></script>
  <script src="env2.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/crypto-js@4.1.1/crypto-js.js"></script>
  <script>
document.addEventListener("DOMContentLoaded", () => {
  const loginForm = document.getElementById("loginForm");
  const mainContent = document.getElementById("mainContent");
  const sessionValidUntil = localStorage.getItem("sessionValidUntil");
  const now = Date.now();
  const premiumForm = document.getElementById("premiumForm");
  const premiumIcon = document.getElementById("premiumIcon");
  const scanButton = document.getElementById("scanButton");
  const submitBtn = document.getElementById("submitBtn");
  const statusMsg = document.getElementById("statusMsg");

  // Session Login Logic
  if (sessionValidUntil && now < parseInt(sessionValidUntil)) {
    loginForm.style.display = "none";
    mainContent.style.display = "block";
    showError("Welcome back! You're still logged in.");
  } else {
    localStorage.removeItem("sessionValidUntil");
    loginForm.style.display = "block";
    mainContent.style.display = "none";
  }

  // UID Logic
  let uid = localStorage.getItem("uid");
  if (!uid) {
    uid = crypto.randomUUID();
    localStorage.setItem("uid", uid);
  }
  document.getElementById("deviceCode").innerText = uid;

  premiumIcon.addEventListener("click", () => {
  const premiumForm = document.getElementById("premiumForm");
  const premiumBox = document.getElementById("premiumStatusBox");
  const statsBox = document.getElementById("todayStatsBox");

  // Close stats box if open
  if (statsBox && statsBox.style.display === "block") {
    statsBox.style.display = "none";
  }

  // Premium user
  if (window.isPremium && window.premiumStatus) {
    const { daysLeft, expiresOn } = window.premiumStatus;
    premiumBox.innerHTML = `
      <div style="margin-bottom: 8px;"><strong style="color: #22c55e;">✅ Premium Access</strong></div>
      <div>🗓️ <strong>${daysLeft} days</strong> remaining</div>
      <div>📅 Expires: ${expiresOn}</div>
    `;
    premiumBox.style.display = premiumBox.style.display === "block" ? "none" : "block";
    premiumForm.style.display = "none";

    // Optional: auto-hide
    setTimeout(() => {
      premiumBox.style.display = "none";
    }, 5000);

  } else {
    // Not premium → toggle form
    const isFormVisible = premiumForm.style.display === "block";
    premiumForm.style.display = isFormVisible ? "none" : "block";
    premiumBox.style.display = "none";
  }
});

statsIcon.addEventListener("click", () => {
  const statsBox = document.getElementById("todayStatsBox");
  const premiumForm = document.getElementById("premiumForm");
  const premiumBox = document.getElementById("premiumStatusBox");

  // Close other boxes
  if (premiumForm && premiumForm.style.display === "block") {
    premiumForm.style.display = "none";
  }
  if (premiumBox && premiumBox.style.display === "block") {
    premiumBox.style.display = "none";
  }

  // Toggle stats
  statsBox.style.display = statsBox.style.display === "none" ? "block" : "none";
});

  // Settings Icon Logic
const settingsIcon = document.getElementById("settingsIcon");
const settingsModal = document.getElementById("settingsModal");
const usdtInput = document.getElementById("usdtInput");
const calculatedMargin = document.getElementById("calculatedMargin");
const saveSettings = document.getElementById("saveSettings");

// Open Settings Modal
settingsIcon.addEventListener("click", () => {
  // Hide other boxes
  const premiumForm = document.getElementById("premiumForm");
  const premiumBox = document.getElementById("premiumStatusBox");
  const statsBox = document.getElementById("todayStatsBox");

  if (premiumForm) premiumForm.style.display = "none";
  if (premiumBox) premiumBox.style.display = "none";
  if (statsBox) statsBox.style.display = "none";

  settingsModal.style.display = "flex";
});

// Calculate margin in real time
usdtInput.addEventListener("input", () => {
  const usdt = parseFloat(usdtInput.value);
  const margin = !isNaN(usdt) ? usdt / 20 : 0;
  calculatedMargin.textContent = `Margin: ${margin.toFixed(2)} USDT`;
});

// Save margin value to localStorage
saveSettings.addEventListener("click", () => {
  const usdt = parseFloat(usdtInput.value);
  if (!isNaN(usdt) && usdt > 0) {
    localStorage.setItem("tradeUSDT", usdt);
    showError(`Trade amount saved: ${usdt} USDT`);
    settingsModal.style.display = "none";
  } else {
    showError("Please enter a valid USDT amount.");
  }
});

async function updateTradeStats() {
  const startOfToday = new Date();
  startOfToday.setUTCHours(0, 0, 0, 0);
  const startTimestamp = startOfToday.getTime();

  try {
    const trades = await sendSignedRequest("/fapi/v1/userTrades", {
      startTime: startTimestamp,
      timestamp: Date.now() + timeOffset
    });

    const tradeGroups = {};

    trades.forEach(t => {
      const key = `${t.symbol}_${t.side}_${t.orderId}`;
      const pnl = parseFloat(t.realizedPnl);

      if (!tradeGroups[key]) {
        tradeGroups[key] = 0;
      }
      tradeGroups[key] += pnl;
    });

    let tp = 0;
    let sl = 0;

    // Adjust thresholds to count more accurately
    Object.values(tradeGroups).forEach(netPnl => {
      if (netPnl > 0.1) tp++;
      else if (netPnl < -0.1) sl++;
    });

    const total = tp + sl;
    const winRate = total ? ((tp / total) * 100).toFixed(1) : 0;

    document.getElementById("tpHit").innerText = tp;
    document.getElementById("slHit").innerText = sl;
    document.getElementById("winRate").innerText = `${winRate}%`;
    document.getElementById("totalTrades").innerText = total;

  } catch (err) {
    console.error("Error updating trade stats:", err);
  }
}

  // Update every minute
  updateTradeStats();
  setInterval(updateTradeStats, 60000);
  
  // Premium Submission to Telegram
  if (submitBtn) {
    submitBtn.addEventListener("click", async () => {
      const senderUid = document.getElementById("senderUidInput").value.trim();
      if (!senderUid) {
        statusMsg.innerText = "❗ Please enter your Binance UID.";
        statusMsg.style.color = "red";
        return;
      }

      const message = `🌟 *Premium Request* 🌟\nDevice Code: \`${uid}\`\nSender UID: ${senderUid}`;
      const telegramUrl = `https://api.telegram.org/bot${window.env2.BOT_TOKEN2}/sendMessage?chat_id=${window.env2.CHAT_ID2}&text=${encodeURIComponent(message)}&parse_mode=Markdown`;

      try {
        await fetch(telegramUrl);
        statusMsg.innerText = "✅ Submitted! Please wait for admin confirmation.";
        statusMsg.style.color = "green";
      } catch {
        statusMsg.innerText = "❌ Submission failed. Please try again.";
        statusMsg.style.color = "red";
      }
    });
  }

  // Premium Check
  fetch("premium-uids.json")
    .then((res) => res.json())
    .then((data) => {
      const entry = data.premium.find((p) => p.uid === uid);
      let isPremium = false;

      if (entry) {
        const expiry = new Date(entry.expires);
        isPremium = now < expiry.getTime();

          if (isPremium) {
    const nowDate = new Date();
    const daysLeft = Math.max(0, Math.ceil((expiry - nowDate) / (1000 * 60 * 60 * 24)));
    window.premiumStatus = {
      uid: entry.uid,
      daysLeft,
      expiresOn: expiry.toDateString()
    };
  }
    } else {
        showError("Premium access not found.");
      }

      window.isPremium = isPremium;
      toggleScanButton();
    })
    .catch(() => {
      showError("Premium check failed.");
    });

  // Trade Count Watcher
  const hideSignalBlocks = () => {
    document.querySelectorAll(".signal-block").forEach((b) => {
      b.style.display = "none";
    });
  };

  const showSignalBlocks = () => {
    document.querySelectorAll(".signal-block").forEach((b) => {
      b.style.display = "block";
    });
  };

  const checkAndSetTradeLimit = async () => {
    try {
      const count = await getOpenPositionsCount();

      if (count >= 10) {
        scanButton.disabled = true;
        localStorage.setItem("scanBlocked", "true");
        hideSignalBlocks();
      } else {
        scanButton.disabled = false;
        localStorage.removeItem("scanBlocked");
        showSignalBlocks();
      }
    } catch (err) {
      console.error("Error checking positions:", err);
    }
  };

  // Initial load: check localStorage
  if (localStorage.getItem("scanBlocked") === "true") {
    scanButton.disabled = true;
    hideSignalBlocks();
  } else {
    checkAndSetTradeLimit(); // Also runs a live check
  }

  // Periodic recheck
  setInterval(checkAndSetTradeLimit, 10000);
});

// Login
function login() {
  const password = document.getElementById("password").value;
  const storedPassword = localStorage.getItem("password");
  if (password === storedPassword) {
    const expiresAt = Date.now() + 72 * 60 * 60 * 1000;
    localStorage.setItem("sessionValidUntil", expiresAt);
    document.getElementById("loginForm").style.display = "none";
    document.getElementById("mainContent").style.display = "block";
    showError("Login successful!");
  } else {
    document.getElementById("loginError").textContent = "Incorrect password!";
  }
}

// Signup
function signup() {
  const pw = document.getElementById("newPassword").value;
  const chatId = document.getElementById("chatId").value;
  const api = document.getElementById("binanceApi").value;
  const secret = document.getElementById("binanceSecret").value;

  if (!pw || !chatId || !api || !secret) {
    document.getElementById("signupError").textContent = "All fields are required!";
    return;
  }

  localStorage.setItem("password", pw);
  localStorage.setItem("chatId", chatId);
  localStorage.setItem("binanceApi", api);
  localStorage.setItem("binanceSecret", secret);
  showLoginForm();
  showError("Signup complete. Please login.");
}

// UI Toggling
function showLoginForm() {
  document.getElementById("signupForm").style.display = "none";
  document.getElementById("loginForm").style.display = "block";
}
function showSignupForm() {
  document.getElementById("loginForm").style.display = "none";
  document.getElementById("signupForm").style.display = "block";
}

let scanInterval = null;
let autoScanActive = false;
    
    const cooldowns = {};
    const COOLDOWN_MINUTES = 60;
    const output = document.getElementById("output");
    const lastTime = document.getElementById("lastTime");

async function getPrecisionInfo(symbol) {
  const res = await fetch('https://fapi.binance.com/fapi/v1/exchangeInfo');
  const data = await res.json();
  const symbolInfo = data.symbols.find(s => s.symbol === symbol);
  if (!symbolInfo) throw new Error('Symbol not found');

  const priceFilter = symbolInfo.filters.find(f => f.filterType === "PRICE_FILTER");
  const lotSize = symbolInfo.filters.find(f => f.filterType === "LOT_SIZE");

  const pricePrecision = Math.round(-Math.log10(parseFloat(priceFilter.tickSize)));
  const quantityPrecision = Math.round(-Math.log10(parseFloat(lotSize.stepSize)));

  return { pricePrecision, quantityPrecision };
}

    async function scan(autoTriggered = false) {
  if (!autoTriggered) {
    clearInterval(scanInterval); // Reset interval when manually scanning
    autoScanActive = true;
    scanInterval = setInterval(() => scan(true), 15000); // Run every 15s
  }

  output.innerHTML = "Scanning...";
  const res = await fetch("https://fapi.binance.com/fapi/v1/ticker/price");
  const coins = await res.json();
  const usdtPairs = coins.filter(c => c.symbol.endsWith("USDT") && !c.symbol.includes("_"));
  const results = await Promise.all(usdtPairs.map(c => analyzeSymbol(c.symbol)));
  const filtered = results.filter(r => r);
  output.innerHTML = filtered.length > 0 ? filtered.join("") : "No strong signals found.";
  lastTime.innerText = "Last scanned: " + new Date().toLocaleTimeString();

  if (filtered.length > 0 && autoScanActive) {
    clearInterval(scanInterval);
    autoScanActive = false;
  }

  return filtered.length > 0;
}

       async function analyzeSymbol(symbol) {
  try {
    const url = `https://fapi.binance.com/fapi/v1/klines?symbol=${symbol}&interval=5m&limit=100`;
    const res = await fetch(url);
    const data = await res.json();

    const closes = data.map(c => parseFloat(c[4]));
    const opens = data.map(c => parseFloat(c[1]));
    const highs = data.map(c => parseFloat(c[2]));
    const lows = data.map(c => parseFloat(c[3]));
    const volumes = data.map(c => parseFloat(c[5]));

    const ema9 = calculateEMA(closes, 9);
    const ema21 = calculateEMA(closes, 21);
    const rsi = calculateRSI(closes, 14);
    const { macd, signal } = calculateMACD(closes);
    const atr = calculateATR(highs, lows, closes, 14);

    if (!ema9.length || !ema21.length || !rsi.length || !macd.length || !signal.length || !atr.length) {
      throw new Error("Insufficient indicator data.");
    }

    const lastClose = closes.at(-1);
    const lastOpen = opens.at(-1);
    const lastHigh = highs.at(-1);
    const lastLow = lows.at(-1);
    const lastVol = volumes.at(-1);
    const avgVol = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;

    const latestEma9 = ema9.at(-1);
    const latestEma21 = ema21.at(-1);
    const latestRsi = rsi.at(-1);
    const latestMacd = macd.at(-1);
    const latestSignal = signal.at(-1);
    const latestAtr = atr.at(-1) || 0;
    const macdHistogram = latestMacd - latestSignal;

    const candleStrength = (lastClose - lastOpen) / lastClose;
    const wickRatio = (lastHigh - lastLow) / lastClose;

    // Config
    const THRESHOLDS = {
      rsiLong: 55,
      rsiShort: 45,
      macdPositive: 0.0,
      macdNegative: 0.0,
      volMultiplier: 1.5,
      candleStrengthMin: 0.002,
      wickRatioMax: 0.02,
      minConfirmCandles: 2
    };

    // Recent candles
    const recentOpens = opens.slice(-3);
    const recentCloses = closes.slice(-3);
    const recentBullishCount = recentCloses.filter((c, i) => c > recentOpens[i]).length;
    const recentBearishCount = recentCloses.filter((c, i) => c < recentOpens[i]).length;

    const dynamicCandleStrength = Math.max(THRESHOLDS.candleStrengthMin, latestAtr * 0.0015);
    const dynamicVolumeThreshold = avgVol * THRESHOLDS.volMultiplier;

    let score = 0, shortScore = 0;
    let scoreReasons = [], shortScoreReasons = [];

if (latestEma9 > latestEma21) { score += 1; scoreReasons.push("EMA9 > EMA21"); }
if (latestRsi > THRESHOLDS.rsiLong) { score += 1; scoreReasons.push("RSI > 55"); }
if (macdHistogram > THRESHOLDS.macdPositive) { score += 1; scoreReasons.push("MACD > 0"); }
if (lastVol > dynamicVolumeThreshold) { score += 1; scoreReasons.push("Volume > Avg * 1.5"); }
if (candleStrength > dynamicCandleStrength) { score += 1; scoreReasons.push("Candle Strength > Threshold"); }
if (wickRatio < THRESHOLDS.wickRatioMax) { score += 1; scoreReasons.push("Wick Ratio < 0.02"); }
if (recentBullishCount >= THRESHOLDS.minConfirmCandles) { score += 1; scoreReasons.push("2+ Bullish Candles"); }

if (latestEma9 < latestEma21) { shortScore += 1; shortScoreReasons.push("EMA9 < EMA21"); }
if (latestRsi < THRESHOLDS.rsiShort) { shortScore += 1; shortScoreReasons.push("RSI < 45"); }
if (macdHistogram < THRESHOLDS.macdNegative) { shortScore += 1; shortScoreReasons.push("MACD < 0"); }
if (lastVol > dynamicVolumeThreshold) { shortScore += 1; shortScoreReasons.push("Volume > Avg * 1.5"); }
if (candleStrength < -dynamicCandleStrength) { shortScore += 1; shortScoreReasons.push("Candle Strength Negative"); }
if (wickRatio < THRESHOLDS.wickRatioMax) { shortScore += 1; shortScoreReasons.push("Wick Ratio < 0.02"); }
if (recentBearishCount >= THRESHOLDS.minConfirmCandles) { shortScore += 1; shortScoreReasons.push("2+ Bearish Candles"); }

let signalType = null;
let confidence = "None";
let reasons = [];

if (score >= 7) {
  signalType = "LONG";
  confidence = "Very High";
  reasons = scoreReasons;
} else if (shortScore >= 7) {
  signalType = "SHORT";
  confidence = "Very High";
  reasons = shortScoreReasons;
} else if (score === 6) {
  signalType = "LONG";
  confidence = "High";
  reasons = scoreReasons;
} else if (shortScore === 6) {
  signalType = "SHORT";
  confidence = "High";
  reasons = shortScoreReasons;
}

if (signalType && symbol) {
          const now = Date.now();
          const lastSignalTime = cooldowns[symbol] || 0;
          if (now - lastSignalTime < COOLDOWN_MINUTES * 60 * 1000) return null;
          cooldowns[symbol] = now;
  
if (marketCondition !== "GOOD") {
  console.log("Signal skipped: Market condition is not GOOD.");
  return null;
}

if (nearPullback) {
  console.log("Signal skipped: BTC is near a potential pullback zone.");
  return null;
}

if ((btcTrend === "bullish" && signalType === "SHORT") ||
    (btcTrend === "bearish" && signalType === "LONG")) {
  console.log(`Signal skipped: BTC is ${btcTrend}, signal direction is ${signalType}`);
  return null;
}

const price = lastClose; 
const atrMultiplier = 2.0; // You can tune this
const rrRatio = 1.2; // Risk\:Reward
const minSlPercent = 0.005; // 0.5%

let sl, tp;

const rawSl = signalType === "LONG"
  ? price - latestAtr * atrMultiplier
  : price + latestAtr * atrMultiplier;

const minSl = price * minSlPercent;

// Ensure SL is not too tight
sl = signalType === "LONG"
  ? Math.min(price - minSl, rawSl)
  : Math.max(price + minSl, rawSl);

// Calculate TP based on SL distance (risk-reward logic)
const risk = Math.abs(price - sl);
tp = signalType === "LONG"
  ? (price + risk * rrRatio)
  : (price - risk * rrRatio);

// Format to 5 decimals (adjust if needed for token precision)
sl = sl.toFixed(5);
tp = tp.toFixed(5);

const escapedReasons = reasons.map(r =>
  r.replace(/&/g, '&amp;')
   .replace(/</g, '&lt;')
   .replace(/>/g, '&gt;')
).join('\n');

const telegramMessage = `
<b>🚨 Signal Alert </b>  
━━━━━━━━━━━━━━━━━  
<b>📊 Pair:</b> <code>${symbol}</code>  
<b>📉 Position:</b> <b><code>${signalType}</code></b>  
<b>🎯 Entry:</b> <code>${price.toFixed(5)}</code>  
<b>⭐ Take Profit:</b> <code>${tp}</code>  
<b>⛔ Stop Loss:</b> <code>${sl}</code>  
<b>⚙️ Leverage:</b> <code>10x – 20x</code>  
<b>🔒 Confidence:</b> <code>${confidence}</code>  
━━━━━━━━━━━━━━━━━  
<b>🧪 Matched Rules:</b>  
<pre>${escapedReasons}</pre>

<b>🧠 Strategy:</b>  
<i>SL is mandatory. Always apply position sizing and risk management.</i>  

<b>🔎 Source:</b> <i>High-confluence algo strategy</i>
`;

await sendToTelegram(telegramMessage);


          return `
<div class="signal-block">
  <b>📊 Symbol:</b> ${symbol}<br>
  <b>🚨 SIGNAL:</b> <span class="${signalType === "LONG" ? "long" : "short"}">${signalType}</span><br>
  <b>💰 Entry:</b> ${price.toFixed(5)}<br>
  <b>⭐ TP:</b> ${tp}<br>
  <b>⛔ SL:</b> ${sl}<br>
  <b>⚙️ Leverage:</b> ${confidence === "High" ? "20x (or max)" : "10–20x"}<br>
  <b>✅ Confidence:</b> <code>${confidence} (score: ${signalType === "LONG" ? score : shortScore})</code>
  <button class="trade-btn" onclick="placeTrade('${symbol}', '${signalType === "LONG" ? "BUY" : "SELL"}', '${price.toFixed(5)}', '${tp}', '${sl}')">Trade</button>
  </div>`;
        }
      } catch (err) {
        console.error("Error analyzing", symbol, err);
        return null;
      }
    }

    function calculateEMA(closes, period) {
      const k = 2 / (period + 1);
      let ema = [closes[0]];
      for (let i = 1; i < closes.length; i++) {
        ema.push(closes[i] * k + ema[i - 1] * (1 - k));
      }
      return ema;
    }

    function calculateRSI(closes, period) {
      let gains = 0, losses = 0;
      for (let i = 1; i <= period; i++) {
        let diff = closes[i] - closes[i - 1];
        if (diff >= 0) gains += diff;
        else losses -= diff;
      }
      let rs = gains / losses;
      let rsi = [100 - 100 / (1 + rs)];

      for (let i = period + 1; i < closes.length; i++) {
        let diff = closes[i] - closes[i - 1];
        if (diff >= 0) {
          gains = (gains * (period - 1) + diff) / period;
          losses = (losses * (period - 1)) / period;
        } else {
          gains = (gains * (period - 1)) / period;
          losses = (losses * (period - 1) - diff) / period;
        }
        rs = gains / losses;
        rsi.push(100 - 100 / (1 + rs));
      }
      return rsi;
    }

    function calculateATR(highs, lows, closes, period) {
      let trs = [];
      for (let i = 1; i < highs.length; i++) {
        const tr = Math.max(
          highs[i] - lows[i],
          Math.abs(highs[i] - closes[i - 1]),
          Math.abs(lows[i] - closes[i - 1])
        );
        trs.push(tr);
      }
      const atr = [trs.slice(0, period).reduce((a, b) => a + b, 0) / period];
      for (let i = period; i < trs.length; i++) {
        atr.push((atr[atr.length - 1] * (period - 1) + trs[i]) / period);
      }
      return atr;
    }

    function calculateMACD(closes) {
  const ema12 = calculateEMA(closes, 12);
  const ema26 = calculateEMA(closes, 26);

  const macd = ema12.slice(ema26.length - ema12.length).map((v, i) => v - ema26[i]);
  const signal = calculateEMA(macd, 9);

  return { macd, signal };
}

  
function getBinanceCredentials() {
  return {
    apiKey: localStorage.getItem('binanceApi'),
    secretKey: localStorage.getItem('binanceSecret')
  };
}

function getTelegramCredentials() {
  return {
    chatId: localStorage.getItem('chatId')
  };
}
  
    async function sendToTelegram(message) {
      const { chatId } = getTelegramCredentials();
      const botToken = window.env.BOT_TOKEN;
      
      await fetch(`https://api.telegram.org/bot${botToken}/sendMessage`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ chat_id: chatId, text: message, parse_mode: "HTML" })
      });
    }

const { apiKey: binanceKey, secretKey: binanceSecret } = getBinanceCredentials();
 
async function placeTrade(symbol, side, entry, tp, sl) {
  try {
    const { pricePrecision, quantityPrecision } = await getPrecisionInfo(symbol);
    const quantity = await getQuantity(symbol, entry, quantityPrecision);
    const leverage = await getSafeLeverage(symbol);

    await setLeverage(symbol, leverage);

    const adjustedPrice = parseFloat(entry).toFixed(pricePrecision);
    const response = await sendLimit(symbol, side, quantity, adjustedPrice, tp, sl, false, pricePrecision, quantityPrecision);

    if (!response || response.code) {
      console.error("Error placing order:", response ? response.msg : "Unknown error");
      showError("Error placing order.");
    }
  } catch (error) {
    console.error("Error in placeTrade function:", error);
    showError("An error occurred while placing the trade.");
  }
}

let isWindowActive = true;
window.addEventListener("beforeunload", () => {
  isWindowActive = false;
});

async function sendLimit(symbol, side, qty, price, tp, sl, reduceOnly, pricePrecision, quantityPrecision) {
  if (!isWindowActive) {
    console.warn("Window inactive. Order not sent.");
    return;
  }

  try {
    const orderParams = {
      symbol: symbol,
      side: side,
      positionSide: side === 'BUY' ? 'LONG' : 'SHORT',
      type: 'MARKET',
      quantity: parseFloat(parseFloat(qty).toFixed(quantityPrecision)),
      timestamp: Date.now()
    };

    if (reduceOnly) orderParams.reduceOnly = true;

    const response = await sendSignedRequest('/fapi/v1/order', orderParams, "POST");
    console.log("Order response:", response);

    if (response && !response.code) {
      const positionSide = side === 'BUY' ? 'LONG' : 'SHORT';
      const oppositeSide = side === 'BUY' ? 'SELL' : 'BUY';

      // TAKE PROFIT
      try {
        await sendSignedRequest('/fapi/v1/order', {
          symbol,
          side: oppositeSide,
          type: 'TAKE_PROFIT_MARKET',
          stopPrice: parseFloat(tp).toFixed(pricePrecision),
          closePosition: true,
          positionSide,
          priceProtect: true,
          timestamp: Date.now()
        }, "POST");
        console.log("✅ TP set for", symbol);
      } catch (tpErr) {
        console.error("❌ TP error for", symbol, tpErr);
        showError(`Failed to set TP for ${symbol}`);
      }

      // STOP LOSS
      try {
        await sendSignedRequest('/fapi/v1/order', {
          symbol,
          side: oppositeSide,
          type: 'STOP_MARKET',
          stopPrice: parseFloat(sl).toFixed(pricePrecision),
          closePosition: true,
          positionSide,
          priceProtect: true,
          timestamp: Date.now()
        }, "POST");
        console.log("✅ SL set for", symbol);
      } catch (slErr) {
        console.error("❌ SL error for", symbol, slErr);
        showError(`Failed to set SL for ${symbol}`);
      }
    }

    return response;

  } catch (mainErr) {
    console.error("❌ Order error:", mainErr);
    showError(`Order failed for ${symbol}`);
    return null;
  }
}

    async function setLeverage(symbol, lev) {
      return sendSignedRequest('/fapi/v1/leverage', {
        symbol,
        leverage: lev,
        timestamp: Date.now()
      }, "POST");
    }

    async function getSafeLeverage(symbol) {
  const res = await sendSignedRequest('/fapi/v1/leverageBracket', {}, 'GET');
  
  // res is an array of objects with symbol and brackets
  const pair = res.find(p => p.symbol === symbol);

  if (!pair || !pair.brackets || pair.brackets.length === 0) {
    console.warn(`Leverage bracket not found for ${symbol}`);
    return 10; // default fallback leverage
  }

  const maxLeverage = pair.brackets[0].initialLeverage;
  return Math.min(maxLeverage, 20);
}
    
  async function getQuantity(symbol, price, quantityPrecision) {
  const usdt = window.env.TRADE_USDT; // USDT amount to use
  const qty = usdt / parseFloat(price);
  return parseFloat(qty).toFixed(quantityPrecision);
    }

async function getBTCIndicators() {
  const res = await fetch("https://fapi.binance.com/fapi/v1/klines?symbol=BTCUSDT&interval=5m&limit=200");
  const data = await res.json();

  const closes = data.map(c => parseFloat(c[4]));
  const volumes = data.map(c => parseFloat(c[5]));

  const ema50 = getEMA(closes, 50);
  const ema200 = getEMA(closes, 200);
  const currentVolume = volumes[volumes.length - 1];
  const avgVolume = volumes.slice(-30).reduce((a, b) => a + b, 0) / 30;

  const priceNow = closes[closes.length - 1];
  const priceBefore = closes[closes.length - 6]; // ~25 minutes ago
  const priceRising = priceNow > priceBefore;

  let trend = "bearish";
  if (ema50[ema50.length - 1] > ema200[ema200.length - 1] && priceRising) {
    trend = "bullish";
  }

  // Debug output
  console.log(`BTC Trend: ${trend}`);
  console.log(`EMA50: ${ema50[ema50.length - 1].toFixed(2)} | EMA200: ${ema200[ema200.length - 1].toFixed(2)}`);
  console.log(`Price Now: ${priceNow} | Price 25min ago: ${priceBefore}`);
  console.log(`Volume: ${currentVolume} | AvgVolume(30): ${avgVolume}`);

  return {
    ema50: ema50[ema50.length - 1],
    ema200: ema200[ema200.length - 1],
    currentVolume,
    avgVolume,
    trend
  };
}

function getEMA(prices, period) {
  const k = 2 / (period + 1);
  const ema = [prices.slice(0, period).reduce((a, b) => a + b, 0) / period];

  for (let i = period; i < prices.length; i++) {
    ema.push(prices[i] * k + ema[ema.length - 1] * (1 - k));
  }

  return ema;
}

let marketCondition = "BAD";
let btcTrend = "bearish";
let nearPullback = false;
    
async function updateMarketCondition() {
  const { ema50, ema200, currentVolume, avgVolume, trend } = await getBTCIndicators();

  const emaGap = Math.abs(ema50 - ema200) / ema200;
  const trendOkay = emaGap > 0.002;
  const noVolumeSpike = currentVolume < avgVolume * 1.8;

  marketCondition = (trendOkay && noVolumeSpike) ? "GOOD" : "BAD";
  btcTrend = trend;

  nearPullback = emaGap > 0.01;
  console.log(`Near Pullback: ${nearPullback}`);

  const pullbackEl = document.getElementById("pullbackStatus");
if (pullbackEl) {
  const valueEl = pullbackEl.querySelector(".value");
  const isRisky = nearPullback;

  valueEl.textContent = isRisky ? "true" : "false";
  pullbackEl.style.color = isRisky ? "#f97316" : "#22c55e"; // Orange for risky, Green for normal
}

  const statusEl = document.getElementById("marketStatus");
  if (statusEl) {
    
    if ((marketCondition === "GOOD" && btcTrend === "bearish") || (marketCondition === "BAD" && btcTrend === "bullish")) {
      const marketColor = marketCondition === "GOOD" ? "#22c55e" : "#b91c1c";
      const trendColor = btcTrend === "bullish" ? "#22c55e" : "#b91c1c";

      statusEl.innerHTML = `<i class="fas fa-signal"></i> <span style="color:${marketColor}">${marketCondition}</span> <span style="color:${trendColor}">${btcTrend.toUpperCase()}</span>`;
      } else {
      
      const color = (marketCondition === "GOOD" && btcTrend === "bullish") ? "#22c55e" : "#b91c1c";
      statusEl.innerHTML = `<i class="fas fa-signal"></i> ${marketCondition} ${btcTrend.toUpperCase()}`;
      statusEl.style.color = color;
    }
  }

  toggleScanButton();
}

updateMarketCondition();
setInterval(updateMarketCondition, 25000); // Update every 25s

function toggleScanButton() {
  const scanButton = document.getElementById("scanButton");
  const waitingMessage = document.getElementById("waitingMessage");

  if (isPremium && marketCondition === "GOOD" && !nearPullback) {
    scanButton.style.display = "inline-block";
    waitingMessage.style.display = "none";
  } else {
    scanButton.style.display = "none";
    waitingMessage.style.display = isPremium ? "block" : "none";
  }
}

 window.onload = async () => {
  const balance = await getFuturesBalance();
  document.getElementById("futuresBalance").innerHTML = `<i class="fas fa-wallet"></i> ${balance}`;

  const positionCount = await getOpenPositionsCount();
  document.getElementById("positionsCount").innerHTML = `<i class="fas fa-chart-line"></i> ${positionCount}/10`;

  const pnl = await getTodayPnL();
  document.getElementById("todayPnl").innerHTML = `<i class="fas fa-dollar-sign"></i> ${pnl >= 0 ? "+" : ""}$${pnl.toFixed(2)}`;
};
    
async function getFuturesBalance() {
  const data = await sendSignedRequest("/fapi/v2/account");
  const usdtAsset = data.assets.find(a => a.asset === "USDT");
  return usdtAsset ? parseFloat(usdtAsset.availableBalance).toFixed(2) : "0.00";
}

async function getOpenPositionsCount() {
  const positions = await sendSignedRequest("/fapi/v2/positionRisk");
  const openPositions = positions.filter(p => parseFloat(p.positionAmt) !== 0);
  return openPositions.length;
}

async function getTodayPnL() {
  try {
    // Get UTC midnight timestamp
    const startOfToday = new Date();
    startOfToday.setUTCHours(0, 0, 0, 0);
    const startTimestamp = startOfToday.getTime();

    // Fetch realized PNL entries from Binance
    const incomeData = await sendSignedRequest("/fapi/v1/income", {
      incomeType: "REALIZED_PNL",
      startTime: startTimestamp,
      limit: 1000
    });

    // Filter for today's entries only (UTC)
    const today = new Date().toISOString().split("T")[0];
    const todayPnl = incomeData
      .filter(entry => {
        const entryDate = new Date(entry.time).toISOString().split("T")[0];
        return entry.incomeType === "REALIZED_PNL" && entryDate === today;
      })
      .reduce((sum, entry) => sum + parseFloat(entry.income), 0);

    // Display
const pnlElement = document.getElementById("pnlValue");
const valueSpan = pnlElement.querySelector(".value");

// Update value
valueSpan.textContent = `${todayPnl >= 0 ? '+' : ''}${todayPnl.toFixed(2)}`;

// Remove old class and apply new one
valueSpan.classList.remove("profit", "loss", "neutral");
valueSpan.classList.add(
  todayPnl > 0 ? "profit" :
  todayPnl < 0 ? "loss" :
  "neutral"
);
    return todayPnl;
  } catch (error) {
    console.error("Error fetching today's PnL:", error);
    showError("Failed to fetch PNL");
  }
} 
    
let timeOffset = 0;

// Sync local time with Binance server
async function syncServerTime() {
  try {
    const res = await fetch("https://fapi.binance.com/fapi/v1/time");
    const data = await res.json();
    const localTime = Date.now();
    timeOffset = data.serverTime - localTime;
    console.log("Time offset (ms):", timeOffset);
  } catch (err) {
    console.warn("Failed to sync Binance time.");
  }
}

syncServerTime(); // Call once at load
setInterval(syncServerTime, 10 * 60 * 1000); // Re-sync every 10 mins
  
    async function sendSignedRequest(path, params = {}, method = "GET") {
  // Add recvWindow and timestamp
  params.recvWindow = 10000; // 5 seconds tolerance
  params.timestamp = Date.now() + timeOffset;

  const query = new URLSearchParams(params).toString();
  const signature = CryptoJS.HmacSHA256(query, binanceSecret).toString(CryptoJS.enc.Hex);

  const fullUrl = `https://fapi.binance.com${path}?${query}&signature=${signature}`;
  const options = {
    method,
    headers: { 'X-MBX-APIKEY': binanceKey }
  };

  // Handle both GET and POST requests
  return fetch(fullUrl, options).then(async r => {
    const data = await r.json();
    if (!r.ok) {
      console.error("Binance API error:", data);
      showError(`Binance Error: ${data.msg || "Unknown error"}`);
    }
    return data;
  });
}
  
function showError(msg) {
  const box = document.createElement('div');
  box.textContent = msg;
  box.style.cssText = `
      position:fixed; top:20px; left:50%; transform:translateX(-50%);
      max-width:90%; padding:14px 18px;
      background:#b91c1c; color:#fef2f2; font-family:monospace;
      border-radius:8px; z-index:9999;
  `;
  document.body.appendChild(box);
  setTimeout(()=> box.remove(), 5000);  // disappear after 5 s
}

    async function refreshStatsAndMarket() {
  try {
    const balance = await getFuturesBalance();
    document.getElementById("futuresBalance").innerHTML = `<i class="fas fa-wallet"></i> ${balance}`;

    const positionCount = await getOpenPositionsCount();
    document.getElementById("positionsCount").innerHTML = `<i class="fas fa-chart-line"></i> ${positionCount}/10`;

    const pnl = await getTodayPnL();
    document.getElementById("todayPnl").innerHTML = `<i class="fas fa-dollar-sign"></i> ${pnl >= 0 ? "+" : ""}$${pnl.toFixed(2)}`;

    console.log("Refreshed at:", new Date().toLocaleTimeString());
  } catch (err) {
    console.error("Error during refresh:", err);
  }
}

window.onload = () => {
  refreshStatsAndMarket(); // initial call
  setInterval(refreshStatsAndMarket, 60000); // auto-refresh every 1 min
};
    
  </script>
</body>
</html>
